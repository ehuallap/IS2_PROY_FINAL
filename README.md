# Proyecto Final de Ingenier铆a de Software: Scooby Attendance

## Trello

 [Enlace](https://trello.com/invite/b/q2yXLGNM/04a48536b6d5f02e8ac25edefeeedf0f/scooby-attendance)

<p align="center">
  <img src="https://github.com/VILLA7523/theoriginscooby/blob/main/WEB/src/public/images/logodog.png?raw=true" alt="Sublime's custom image"/>
</p>


## Contexto
Debido a la coyuntura actual generada por el virus SARS COV-2, las clases virtuales se ha vuelto un est谩ndar a nivel mundial, esto nos llev贸 a poder redefinir las maneras de como realizar muchas de nuestras actividades, algunas con mayor facilidad y otras que sean dificultados.

Como sabemos la 茅poca actual exige personas altamente cualificadas, capaces de adaptarse a los cambios constantes y de innovar, no solo para garantizar su sostenibilidad y su 茅xito en el mercado mundial, sino tambi茅n para promover el crecimiento econ贸mico. 

Hasta ahora, hay indicios de que la asistencia regular contribuye al 茅xito de los estudiantes no s贸lo en el marco escolar sino tambi茅n en la vida real. Sin embargo, los datos revelan que un alto porcentaje de estudiantes abandona la universidad, lo que significa que varios candidatos de gran potencial no contin煤an sus estudios . Adem谩s, parece que se ha prestado poca atenci贸n a la importancia de la asistencia de los alumnos y a su repercusi贸n en el rendimiento escolar.

En uno de los intentos de poder solucionar este problema se gener贸 la asistencia, con el fin de llevar registro de las personas que debieran estar atendiendo a clases, m谩s por la pandemia este sistema ha sido modificado y adaptado en la mayor铆a de los casos por formas est谩ticas como llenar un peque帽o formulario o el llamado de una lista. 

Esto genera mucho tiempo perdido, siendo un proceso muy ineficiente para el aprendizaje, antes esta situaci贸n nos planteamos como podemos optimizar y agilizar este proceso.


## 驴Qu茅 es Scooby Attendance?
El proceso de control de la asistencia en cualquier instituci贸n es una parte importante para determinar la eficacia de los servicios ofrecidos por la misma y el inter茅s general de quienes se benefician de los servicios de la instituci贸n, en nuestro caso, los estudiantes. Este proceso es una rutina engorrosa, y por ello, el presente art铆culo propone una nueva forma de reemplazar el antiguo sistema, que implica registros de asistencia que tienen que ser llenados uno por uno para cada alumno, ya que este m茅todo requiere mucho tiempo y es propenso a cometer errores, ya sea marcando a un alumno como ausente por error o contando un n煤mero err贸neo de asistencias cuando hay que entregar informes o estad铆sticas.

## Objetivos

### Objetivo General
Renovar completamente el proceso de toma de asistencia para los docentes y estudiantes de la universidad, haci茅ndolo mas eficiente y ahorrando tiempo.
### Objetivos Espec铆ficos
* *Implementar el uso de marcadores biom茅tricos.*
* *Integrar plataformas m贸viles con plataformas web*
* *Poner en funcionamiento bases de datos y servidores que funcione conjuntamente con la aplicaci贸n.*
* *Estudiar el desarrollo de aplicaciones Android y aplicaciones web.*
* *Disminuir la carga laboral del personal docente y administrativo.*

## Propuesta
La asistencia es una de las tareas administrativas que deben realizarse al comienzo de cada clase. Esto conlleva a la p茅rdida de tiempo valioso al comienzo de  la clase que es aproximadamente el 10\% de la misma y a veces es dif铆cil de gestionar. Es por ello que es necesaria la elaboraci贸n de una aplicaci贸n m贸vil y web que utilice m茅todos de identificaci贸n biom茅trica y de identificaci贸n convencional, aplicando el uso de base de datos relaciones junto con la implementaci贸n de APIs; adem谩s el uso de una plataforma web desde donde se podr谩 administrar la aplicaci贸n, mostrar estad铆sticas de los estudiantes y de las clases en general utilizando tecnolog铆as modernas como son HTML5, CSS, Javascript, Web Services, Base de datos relacional. 

## Beneficios
* **Ahorrar tiempo**: Con nuestro sistema tendremos un 煤nico punto de referencia para los registros de asistencia de toda la universidad. No es necesario utilizar los tradicionales m煤ltiples registros.
* **Aumentar la precisi贸n:** Con el sistema se reduce dr谩sticamente el error humano y los profesores pueden justificar eficientemente inasistencias o tardanza.
* **Garantizar la integridad de los datos:** En comparaci贸n con los anticuados registros en papel o excel que pueden perderse, destruirse o eliminarse accidentalmente, sus registros de asistencia est谩n seguros; y disponibles en la nube.
* **Mejorar la productividad de las clases:** Ya que no se perder谩 tiempo en la toma de asistencia.
* **Reducir el trabajo administrativo:** Los registros y estad铆sticas estar谩n disponibles al instante.
* **Disminuir los costes administrativos:** Que requieren gasto de tiempo y trabajo repetitivo.

## Impacto Social
La iniciativa tiene repercusiones positivas para:
**Estudiantes:** Reducci贸n del el absentismo, aumentar la puntualidad, mejorar la concentraci贸n, la retenci贸n, el rendimiento y el 茅xito.
**Docentes:** Gestionar y mantener la asistencia ya no es una molestia. Toma de asistencia r谩pida y eficiente.
**Direcci贸n de las Escuelas y Facultades:** El equipo directivo recibe informes de asistencia generados autom谩ticamente al final de cada d铆a.


## Diagrama de Clases

<p align="center">
  <img src="https://github.com/MrsblR/FinalProjectIS/blob/main/Evidences/D02.jpg" alt="Sublime's custom image"/>
</p>

## Diagrama de Casos de Uso

<p align="center">
  <img src="https://github.com/MrsblR/FinalProjectIS/blob/main/Evidences/D01.jpeg" alt="Sublime's custom image"/>
</p>


## Wireframes
Para las diagramamaciones de las se utiliz贸 Figma

**Link APP:** -  [Versi贸n App](https://www.figma.com/file/98YCTCsRYmb6R7Mibg79dR/Scooby-Attendance?node-id=0%3A1)
**Link WEB** - [Versi贸n Web](https://www.figma.com/file/VvYuJi1rbh2pscG7iIGO3n/Admin-Dashboard)


## Funcionalidades

 - [X] Iniciar sesi贸n.
 - [X] Cerrar sesi贸n.
 - [X] Asignar curso a estudiante.
 - [ ] Ver estad铆sticas de asistencia.
 - [ ] Generar reportes.
 - [X] Crear curso.
 - [X] Editar curso.
 - [X] Eliminar curso.
 - [X] Crear horario.
 - [ ] Editar horario.
 - [ ] Eliminar horario.
 - [X] Ver cursos.
 - [X] Ver horarios.
 - [X] Marcar asistencia.
 - [ ] Ver asistencia por curso




##  Para inicializar el proyecto WEB
Ejecute primero los siguientes comandos
```
cd attendance
npm install
npm run dev
```

##  Para inicializar el proyecto Android
Ejecute primero los siguientes comandos
```
emulator -avd scooby
```
## ESTILOS DE LA PROGRAMACIN
- Letterbox
- Tantrum
- Aspects
- Persistent Tables
- Declared Intentions
- Things

### Estilo 1 - Letterbox

#### Descripci贸n
- El problema m谩s grande se descompone en 'cosas' que tienen sentido para el dominio del problema.
- Cada 'cosa' es una c谩psula de datos que expone un solo procedimiento, a saber, la capacidad de recibir y enviar mensajes que se le env铆an.
- El env铆o de mensajes puede resultar en el env铆o del mensaje a otra c谩psula.

#### Fragmento de c贸digo

``` javascript
const express = require("express");
const router = express.Router();
const connectionDb = require("../../config/dbconnections");

class CityModel {
  async getAll() {
    const con = connectionDb.promise();
    const data = await con.query("SELECT * FROM city");
    return data[0];
  }
  async get(id) {
    const con = connectionDb.promise();
    const data = await con.query("SELECT * FROM city WHERE CityID = ?", [id]);
    return data[0];
  }
  async findByName(city) {
    const con = connectionDb.promise();
    const data = await con.query("SELECT * FROM city WHERE City_Name = ?", [
      city,
    ]);
    return data[0];
  }
}
module.exports = CityModel;
```

### Estilo 2 - Tantrum

#### Descripci贸n
- Cada procedimiento y funci贸n verifica la cordura de sus argumentos y se niega a continuar cuando los argumentos no son razonables.
- Todos los bloques de c贸digo verifican todos los posibles errores, posiblemente imprimen mensajes espec铆ficos del contexto cuando ocurren errores y pasan los errores a la cadena de llamadas de funci贸n

#### Fragmento de c贸digo
``` javascript
const express = require("express");
const router = express.Router();
const VerifyModel = require("../../domain/models/verify.model");
const verifyDb = new VerifyModel();
const CityModel = require("../../domain/models/city.model");
const cityDb = new CityModel();
const CourseModel = require("../../domain/models/course.model");
const SectionModel = require("../../domain/models/section.model");
const sectionDb = new SectionModel();
const TypeModel = require("../../domain/models/type.model");
const typeDb = new TypeModel();
const PersonModel = require("../../domain/models/person.model");
const personDb = new PersonModel();
const courseDb = new CourseModel();

const CourseService = require("../../aplication/services/course.service");
const CourseRepository = require("../../domain/repository/course.repository");

const CityService = require("../../aplication/services/city.service");
const CityRepository = require("../../domain/repository/city.repository");

const TypeService = require("../../aplication/services/type.service");
const TypeRepository = require("../../domain/repository/type.repository");

const SectionService = require("../../aplication/services/type.service");
const SectionRepository = require("../../domain/repository/type.repository");


class DataController {
  constructor() { }
  async getAllPerson() {
    var personRepository = new TypeRepository(personDb);
    var personService = new TypeService(personRepository);
    const result = personService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllVerify() {
    var verifyRepository = new VerifyRepository(personDb);
    var verifyService = new VerifyService(verifyRepository);
    const result = verifyService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCities() {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const data = await cityService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }


  async getAllType() {
    var typeRepository = new TypeRepository(typeDb);
    var typeService = new TypeService(typeRepository);
    const data = await typeService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllSection() {
    var sectionRepository = new SectionRepository(sectionDb);
    var sectionService = new SectionService(sectionRepository);
    const result = sectionService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityByName(name) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.findByName(name);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityById(id) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.get(id);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCourses() {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseById(id) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.get(id)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseByName(name) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.findByName(name)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }
}
module.exports = DataController;
```

### Estilo 3 - Aspects

#### Descripci贸n
- El problema se descompone utilizando alguna forma de abstracci贸n (procedimientos, funciones, objetos, etc.)
- Los aspectos del problema se agregan al programa principal sin editar el c贸digo fuente de las abstracciones. Estas funciones secundarias se aferran a las abstracciones principales nombr谩ndolas, como en "Soy un aspecto de foo (隆aunque puede que foo no lo sepa!)".
#### Fragmento de c贸digo
``` javascript
class DataController {
  constructor() { }

  async getAllPerson() {
    var personRepository = new TypeRepository(personDb);
    var personService = new TypeService(personRepository);
    const result = personService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllVerify() {
    var verifyRepository = new VerifyRepository(personDb);
    var verifyService = new VerifyService(verifyRepository);
    const result = verifyService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCities() {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const data = await cityService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }


  async getAllType() {
    var typeRepository = new TypeRepository(typeDb);
    var typeService = new TypeService(typeRepository);
    const data = await typeService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllSection() {
    var sectionRepository = new SectionRepository(sectionDb);
    var sectionService = new SectionService(sectionRepository);
    const result = sectionService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityByName(name) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.findByName(name);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityById(id) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.get(id);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCourses() {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseById(id) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.get(id)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseByName(name) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.findByName(name)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }
}

module.exports = DataController;
```

Uso de clases y funciones referente

``` javascript
const BaseRepository = require("./base.repository");

class CityRepository extends BaseRepository {
  constructor(CityDb) {
    super(CityDb);
  }

  async getAllWithoutPagination() {
    return this.model.find();
  }
}

module.exports = CityRepository;
```

### Estilo 4 Persistent Tables

#### Descripci贸n

- Los datos de entrada del problema se modelan como entidades con relaciones entre ellas

- Los datos se colocan en tablas, con columnas que potencialmente hacen referencia cruzada a datos en otras tablas

- Existencia de un motor de consulta relacional

- El problema se resuelve emitiendo consultas sobre los datos tabulares.

#### Fragmento de c贸digo

```javascript
async findByName(city) {
  const con = connectionDb.promise();
  const data = await con.query("SELECT * FROM city WHERE City_Name = ?", [
    city,
  ]);
  return data[0];
}
async getAll() {
  const connection = connectionDb.promise();
  const data = await con.query(
    "SELECT * FROM student INNER JOIN person ON student.PersonID = person.PersonID INNER JOIN city ON person.CityID = city.CityID"
  );
  return data[0];
}
```

### Estilo 5 Declared Intentions

#### Descripci贸n

- Existencia de un verificador de tipos en tiempo de ejecuci贸n

- Los procedimientos y funciones declaran qu茅 tipos de argumentos esperan

- Si las personas que llaman env铆an argumentos de tipos que no se esperan, el
   los procedimientos/funciones no se ejecutan.
  
#### Fragmento de c贸digo
 
```javascript
  async deleteInscription(id, StudentId) {
    if (!id || !StudentId) {
      const error = new Error();
      error.status = 100;
      error.message = "El par谩metro ID debe ser enviado";
      throw error;
    }
    const entity = await this.repository.deleteInscription(id, StudentId);
    if (!entity) {
      const error = new Error();
      error.status = 500;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }
```

### Estilo 6 Things

#### Descripci贸n

- El problema mayor se descompone en 'cosas' que tienen sentido para el dominio del problema.
- Cada 'cosa' es una c谩psula de datos que expone procedimientos al resto del mundo.
- Nunca se accede a los datos directamente, solo a trav茅s de estos procedimientos.
- Las c谩psulas pueden reapropiarse de procedimientos definidos en otras c谩psulas.

#### Fragmento de c贸digo
```javascript
class BaseRepository {
  constructor(model) {
    this.model = model;
  }
  async get(id) {
    return this.model.get(id);
  }
  async getAll() {
    return this.model.getAll();
  }
  async getByName(name) {
    return this.model.getByName(name);
  }
  async create(entity) {
    return this.model.create(entity);
  }
  async update(entity) {
    return this.model.update(entity);
  }
  async delete(id) {
    return this.model.delete(id);
  }
}
```





## CODIFICACIN LEGIBLE (CLEAN CODE)

- Comentarios
- Reglas de nombres
- Consejos de comprensibilidad
- Reglas de funciones
- Objetos y estructuras de datos
- Captalize SQL Special Words

### Clean Code 1 - Comentarios

#### Descripci贸n

- Intenta siempre explicarte en c贸digo.
- No seas redundante.
- No agregue ruido obvio.
- No use comentarios de llaves de cierre.
- No comente el c贸digo. Solo elimina.
- Utilizar como explicaci贸n de la intenci贸n. 
- Utilizar como aclaraci贸n de c贸digo.
- Utilizar como advertencia de las consecuencias.

#### Framgmento de c贸digo

Uso de comentarios respetando las reglas designadas 

``` javascript
const express = require("express");
const router = express.Router();
const PersonModel = require("../../domain/models/person.model");
const personDb = new PersonModel();
const LoginModel = require("../../domain/models/login.model");
const loginDb = new LoginModel();
const ProfessorModel = require("../../domain/models/professor.model");
const professorDb = new ProfessorModel();
const InscriptionModel = require("../../domain/models/inscription.model");
const inscriptionDb = new InscriptionModel();
const CourseModel = require("../../domain/models/course.model")
const courseDb = new CourseModel();
const CourseStudentsModel = require("../../domain/models/course_student.model");
const courseStudentsDb = new CourseStudentsModel();
const SheduleModel = require("../../domain/models/shedule.model");
const sheduleDb = new SheduleModel();

const ProfessorService = require("../../aplication/services/professor.service");
const ProfessorRepository = require("../../domain/repository/professor.repository");

const InscriptionService = require("../../aplication/services/inscription.service");
const InscriptionRepository = require("../../domain/repository/inscription.repository");

const SheduleService = require("../../aplication/services/shedule.service");
const SheduleRepository = require("../../domain/repository/shedule.repository");

const CourseService = require("../../aplication/services/course.service");
const CourseRepository = require("../../domain/repository/course.repository");

const PersonService = require("../../aplication/services/person.service");
const PersonRepository = require("../../domain/repository/person.repository");

const LoginService = require("../../aplication/services/login.service");
const LoginRepository = require("../../domain/repository/login.repository");

const CourseStudentsService = require("../../aplication/services/courseStudents.service");
const CourseStudentsRepository = require("../../domain/repository/courseStudents.repository");

class ProfessorController {
  async getAll() {
    var professorRepository = new ProfessorRepository(professorDb);
    var professorService = new ProfessorService(professorRepository);
    const result = profesorService.getAll()
    const data = await result.catch((err) => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findBydCode(code) {
    var professorRepository = new ProfessorRepository(professorDb);
    var professorService = new ProfessorService(professorRepository);
    const result = professorService.findBydCode(code)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async studentInscription(StudentID, CourseID) {
    var inscriptionRepository = new InscriptionRepository(inscriptionDb);
    var inscriptionService = new InscriptionService(inscriptionRepository);
    const result = inscriptionService.create({ StudentID, CourseID });
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async NuevoHorario(Day, Start, Finish, CourseID) {
    var sheduleRepository = new SheduleRepository(sheduleDb);
    var sheduleService = new SheduleService(sheduleRepository);
    const result = sheduleService.create({ Day, Start, Finish, CourseID });
    const data = await result.catch((err) => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async GetHorario(CourseID) {
    var sheduleRepository = new SheduleRepository(sheduleDb);
    var sheduleService = new SheduleService(sheduleRepository);
    const result = sheduleService.get(CourseID);
    const data = await result.catch((err) => {
      console.log("controller Error Get Horario ", err);
      return null;
    });
    return data;
  }

  async NuevoCourse(Course_Name, SectionID, TypeID, ProfessorID, NumEst, Semestre) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.create({ Course_Name, SectionID, TypeID, ProfessorID, NumEst, Semestre });
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });

    return data;
  }

  async register(
    First_Name,
    Last_Name,
    Email,
    DNI,
    Mobile_Phone,
    CityID,
    Department,
    Password,
    idDNI) {
    var personRepository = new PersonRepository(personDb);
    var personService = new PersonService(personRepository);
    var professorRepository = new ProfessorRepository(professorDb);
    var professorService = new ProfessorService(professorRepository);
    var loginRepository = new LoginRepository(loginDb);
    var loginService = new LoginService(loginRepository);

    const result = personService.create(

      First_Name,
      Last_Name,
      Email,
      DNI,
      null,
      Mobile_Phone,
      CityID

    );

    const data = await result.catch((err) => {
      console.log("controller Error", err);
      return null;
    });

    let dataId;
    const resultProfessor = professorService.create({ Department, dataId, idDNI });
    const dataProfessor = await resultProfessor.catch(err => {
      console.log("controller Error Professor", err);
      return null;
    })

    let val = null;
    let rol = 1;
    const resultLogin = loginService.create({ Email, Password, val, idDNI, rol });
    const dataLogin = await result.catch((err) => {
      console.log("controller Error", err);
      return null;
    });
    console.log("dataLogin", dataLogin);
    return dataLogin;
  }

  async login(email, password) {
    var loginRepository = new LoginRepository(loginDb);
    var loginService = new LoginService(loginRepository);
    const resulLogin = loginService.authenticate(email, password);
    const dataLogin = await resulLogin.catch((err) => {
      console.log("controller Error", err);
      return null;
    });
    return dataLogin;
  }

  async getAllCourses(id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const resultCourse = await courseService.findByIdProfessor(id)
      .catch((err) => {
        console.log("Controller Error", err);
        return null;
      });
    return resultCourse;
  }


  async getProfessorToCourse(token) {
    var professorRepository = new ProfessorRepository(professorDb);
    var professorService = new ProfessorService(professorRepository);

    const resultProfessor = professorService.findByDNI(token);
    const dataProfessor = await resultProfessor.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return dataProfessor;
  }

  async getStudentsOfCourses(token) {
    var courseStudentsRepository = new CourseStudentsRepository(courseStudentsDb);
    var courseStudentsService = new CourseStudentsService(courseStudentsRepository);

    const resultStudentsCourse = courseStudentsService.studentsForCourse(token);
    const dataStudentsCourse = await resultStudentsCourse.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return dataStudentsCourse;
  }

  async deleteCourse(id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const result = courseService.delete(id);
    const data = await result.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return data;
  }

  async getCourse(id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const result = courseService.get(id)
    const data = await result.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return data;
  }

  async updateCourse(name, section, type, semestre, id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const result = courseService.update({ name, section, type, semestre, id })
    const data = await result.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return data;
  }

}

module.exports = ProfessorController;
```

### Clean Code 2 - Reglas de nombres

- Elija nombres descriptivos e inequ铆vocos.
- Hacer una distinci贸n significativa.
- Usa nombres pronunciables.
- Utilice nombres buscables.
- Reemplace los n煤meros m谩gicos con constantes con nombre.
- Evite las codificaciones. No agregue prefijos ni escriba informaci贸n.


#### Fragmento de c贸digo

Respetando las reglas de nombre , podemos observar en la sigueinte imagen que el nombre de las funciones como el de las variables no son ambiguas , y son muy descriotivas , encontradas en el dataController para m谩s informacion.

``` javascript

class DataController {
  constructor() { }

  async getAllPerson() {
    var personRepository = new TypeRepository(personDb);
    var personService = new TypeService(personRepository);
    const result = personService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllVerify() {
    var verifyRepository = new VerifyRepository(personDb);
    var verifyService = new VerifyService(verifyRepository);
    const result = verifyService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCities() {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const data = await cityService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }


  async getAllType() {
    var typeRepository = new TypeRepository(typeDb);
    var typeService = new TypeService(typeRepository);
    const data = await typeService.getAll().catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllSection() {
    var sectionRepository = new SectionRepository(sectionDb);
    var sectionService = new SectionService(sectionRepository);
    const result = sectionService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityByName(name) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.findByName(name);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCityById(id) {
    var cityRepository = new CityRepository(cityDb);
    var cityService = new CityService(cityRepository);
    const result = cityService.get(id);
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async getAllCourses() {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.getAll();
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseById(id) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.get(id)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }

  async findCourseByName(name) {
    var courseRepository = new CourseRepository(CoursesDb);
    var courseService = new CourseService(courseRepository);
    const result = courseService.findByName(name)
    const data = await result.catch(err => {
      console.log("controller Error", err);
      return null;
    });
    return data;
  }
}

module.exports = DataController;
```

### Clean Code 3 - Consejos de comprensibilidad

#### Despcripci贸n 
- Se consistente. Si haces algo de cierta manera, haz todas las cosas similares de la misma manera.
- Usa variables explicativas.
- Encapsular las condiciones de contorno. Las condiciones de contorno son dif铆ciles de seguir. Ponga el procesamiento para ellos en un solo lugar.
- Prefiere los objetos de valor dedicados al tipo primitivo.
- Evita la dependencia l贸gica.
- No escriba m茅todos que funcionen correctamente dependiendo de otra cosa en la misma clase.
- Evita los condicionales negativos.

#### Fragmento de C贸digo
Uso de variables de entorno uso del c贸digo

``` javascript
require("dotenv").config();
const mysql = require("mysql2");
// create the pool
const pool = mysql.createPool({
  host: process.env.HOST,
  user: process.env.USER,
  database: process.env.DATABASE,
  password: process.env.PASSWORD,
});

module.exports = pool;
```

### Clean Code 4 - Reglas de funciones
#### Descripci贸n
- Peque帽a.
- Haz una cosa.
- Utilice nombres descriptivos.
- Prefiere menos argumentos.
- No tiene efectos secundarios.
- No use argumentos de bandera. Divida el m茅todo en varios m茅todos independientes que se pueden llamar desde el cliente sin la bandera.

#### Fragmento de C贸digo
_1 El nombre de las funciones son descriptivas , adem谩s en todas las funciones realizadas los parametros no exceden de 7 par谩metros referente en el c贸digo en [Click aqui](https://github.com/VILLA7523/FinalProjectIS/blob/main/Application/src/domain/repository/base.repository.js)_

``` javascript
class BaseRepository {
  constructor(model) {
    this.model = model;
  }
  async get(id) {
    return await this.model.get(id);
  }
  async getAll() {
    return await this.model.getAll();
  }
  async getByName(name) {
    return await this.model.getByName(name);
  }
  async create(entity) {
    return await this.model.create(entity);
  }
  async update(entity) {
    return await this.model.update(entity);
  }
  async delete(id) {
    return await this.model.delete(id);
  }
}
module.exports = BaseRepository;
```

### Clean Code 5 - Objetos y estructuras de datos
#### Descripci贸n
- Ocultar estructura interna.
- Preferir estructuras de datos.
- Evita estructuras h铆bridas (mitad objeto y mitad datos).
- Deber铆a ser peque帽o.
- Haz una cosa.
- Peque帽o n煤mero de variables de instancia.
- La clase base no debe saber nada acerca de sus derivados.
- Es mejor tener muchas funciones que pasar algo de c贸digo a una funci贸n para seleccionar un comportamiento.
- Prefiere m茅todos no est谩ticos a m茅todos est谩ticos.

### Fragmento de c贸digo

``` javascript
const BaseService = require("./base.service");

class CourseService extends BaseService {
  constructor(CourseRepository) {
    super(CourseRepository);
    this._CourseRepository = CourseRepository;
  }

  async findByIdProfessor(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Email or password missing";
      throw error;
    }

    const entity = await this.repository.findByIdProfessor(id);

    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Failed authentication";
      throw error;
    }
    return entity;
  }
  //si es true aumenta , si es fals disminuye

  async updateCantEstIn(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro id debe ser enviado";
      throw error;
    }

    const entity = await this.repository.updateCantEstIn(id);

    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async updateCantEstDe(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro id debe ser enviado";
      throw error;
    }

    const entity = await this.repository.updateCantEstDe(id);

    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }
}

module.exports = CourseService;
```

``` javascript
const BaseRepository = require("./base.repository");

class CourseRepository extends BaseRepository {
  constructor(CourseDb) {
    super(CourseDb);
  }
  async findByIdProfessor(id) {
    return await this.model.findByIdProfessor(id);
  }
}

module.exports = CourseRepository
```

``` javascript
  async getCourse(id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const result = courseService.get(id)
    const data = await result.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return data;
  }

  async updateCourse(name, section, type, semestre, id) {
    var courseRepository = new CourseRepository(courseDb);
    var courseService = new CourseService(courseRepository);

    const result = courseService.update({ name, section, type, semestre, id })
    const data = await result.catch((err) => {
      console.log("Controller error", err);
      return null;
    });
    return data;
  }
```

### Clean Code - 6 Capitalize SQL Special Words
#### Descripci贸n
- La interacci贸n con la base de datos es una parte importante de la mayor铆a de las aplicaciones web. Si est谩 escribiendo consultas SQL sin procesar, es una buena idea mantenerlas legibles tambi茅n.
- Aunque las palabras especiales de SQL y los nombres de funciones no distinguen entre may煤sculas y min煤sculas, es una pr谩ctica com煤n usar may煤sculas para distinguirlos de los nombres de tablas y columnas.

Fragmento de C贸digo

## PRINCIPIOS SOLID

- Principio de inversi贸n de dependencia (DIP)
- Principio abierto/cerrado (OCP)
- Interface segregation principle(ISP)
- Liskov Substitution Principle (LSP)

### 1-  Principio de inversi贸n de dependencia (DIP)

#### Descripci贸n
Este principio establece dos cosas esenciales:

- Los m贸dulos de alto nivel no deben depender de los m贸dulos de bajo nivel. Ambos deber铆an depender de abstracciones.
- Las abstracciones no deben depender de los detalles. Los detalles deben depender de las abstracciones.
Esto puede ser dif铆cil de entender al principio,
pero si has trabajado con marcos PHP (como Symfony), has visto una implementaci贸n de este principio en forma de inyecci贸n de dependencia (DI). Si bien no son conceptos id茅nticos, DIP evita que los m贸dulos de alto nivel conozcan los detalles de sus m贸dulos de bajo nivel y los configuren. Puede lograr esto a trav茅s de DI.
Un gran beneficio de esto es que reduce el acoplamiento entre m贸dulos. El acoplamiento es un patr贸n de desarrollo muy malo porque hace que su c贸digo sea dif铆cil de refactorizar.

#### Fragmento de c贸digo
En nuestra implementaci贸n se cumple este principio , un ejemplo de ello son en lo servicios , repository , etc . todas las funciones que se usaran en el proyecto son propias de cada modelo esto quiere decir , que en cada clase se impletan funciones que no comparte con las dem谩s , y las que si son gen茅ricas se establecen en una clase base , tomando en cuenta las principales funciones crud asi como los filtros.

Implementacion de baseService , se puede observar las principales funciones crud.

``` javascript
class BaseService {
  constructor(Repository) {
    this.repository = Repository;
  }
  async get(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro id debe ser enviado";
      throw error;
    }

    const entity = await this.repository.get(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getByName(name) {
    if (!name) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro name debe ser enviado";
      throw error;
    }

    const entity = await this.repository.getByName(name);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getAll() {
    const entity = await this.repository.getAll();
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async create(data) {
    const entity = await this.repository.create(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async update(data) {
    const entity = await this.repository.update(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async delete(id) {
    const entity = await this.repository.delete(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }
}
```

De esta clase base extienden otras como: 

CouserStudetsService , se observa que solo esta implementado funciones propias de esta.

```javascript
const BaseService = require("./base.service");

class CourseStudentsService extends BaseService {
  constructor(CourseStudentsRepository) {
    super(CourseStudentsRepository);
    this._CourseStudentsRepository = CourseStudentsRepository;
  }
  async studentsForCourse(token) {
    if (!token) {
      const error = new Error();
      error.status = 400;
      error.message = "token parameter is missing";
      throw error;
    }

    const entity = await this.repository.studentsForCourse(token);

    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Student not found";
      throw error;
    }
    return entity;
  }
}

module.exports = CourseStudentsService;
```

LoginService , se observa que solo esta implementado funciones propias de esta.

``` javascript
const BaseService = require("./base.service");

class LoginService extends BaseService {
  constructor(LoginRepository) {
    super(LoginRepository);
    this._LoginRepository = LoginRepository;
  }

  async authenticate(email, password) {
    if (!email || !password) {
      const error = new Error();
      error.status = 400;
      error.message = "Email or password missing";
      throw error;
    }

    const entity = await this.repository.authenticate(email, password);

    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Failed authentication";
      throw error;
    }
    return entity;
  }
}

module.exports = LoginService;
```

### 2 - Principio abierto/cerrado (OCP)
#### Descripci贸n
El Principio Abierto/Cerrado, tambi茅n conocido como Open/Closed Principle o por sus siglas OCP, es el segundo de los 5 principios SOLID de la programaci贸n orientada a objetos.

Los m贸dulos que cumplen con el principio abierto-cerrado tienen dos caracter铆sticas principales. Estos son

 - Abiertos para la extensi贸n: Esto significa que el comportamiento del m贸dulo puede ser extendido. Cuando los requerimientos de la aplicaci贸n cambian, debemos ser capaces de extender el m贸dulo con estos nuevos comportamientos que satisfagan esos cambios. En otras palabras, debemos ser capaces de cambiar lo que el m贸dulo hace.
 - Cerrado para la modificaci贸n: Esto significa que extender el comportamiento de un m贸dulo no deber铆a tener como resultado cambiar el c贸digo fuente, es decir, el c贸digo original debe permanecer sin cambios.

#### Fragmento de C贸digo
La siguiente fragmento de c贸digo muestra la implementaci贸n de la clase BaseRepository , en la cual se encuentran las funciones crud , cumple con las caracteristica de este principio ya que se puede observar que en la clase baseRepository estan implementadas las funciones crud , que todos nuestros modelos usaran , de esta clase ectendimos m谩s clases en las cuales hay funciones propias de cada repositorio:

En el siguiente fragmento de c贸digo podemos observar que los par谩metros de las funciones , reciben un objeto , esto con el objetivo de hacer que las funciones sean g茅nericas y cualquier repository que estiendan a ella sean independientes a sus par谩metros 

``` Javascript
class BaseRepository {
  constructor(model) {
    this.model = model;
  }
  async get(id) {
    return this.model.get(id);
  }
  async getAll() {
    return this.model.getAll();
  }
  async getByName(name) {
    return this.model.getByName(name);
  }
  async create(entity) {
    return this.model.create(entity);
  }
  async update(entity) {
    return this.model.update(entity);
  }
  async delete(id) {
    return this.model.delete(id);
  }
}
```

En las siguientes imagenes son nuestras implementaciones .repository que extienden del baseRepository:

implementaci贸n de loginRepository , como se observa authenticate es propio de login , pues ninguna de las otras clases lo comparte , es por eso que est funcionalidad se desarrolla dentro de la clase porpia de esta 

``` javascript
const BaseRepository = require("./base.repository");

class LoginRepository extends BaseRepository {
  constructor(LoginDb) {
    super(LoginDb);
  }

  async authenticate(email , password) {
    return await this.model.authenticate(email , password);
  }
}

module.exports = LoginRepository
```

Implementaci贸n de courseStudentsRepository que extiende de BaseRepository 

``` javascript
const BaseRepository = require("./base.repository");

class CourseStudentsRepository extends BaseRepository {
  constructor(CourseStudentsDb) {
    super(CourseStudentsDb);
  }
  async studentsForCourse(token) {
    return await this.model.studentsForCourse(token);
  }
}

module.exports = CourseStudentsRepository
```

Implementaci贸n de Course que extiende de baseRepository

const BaseRepository = require("./base.repository");

``` javascript
class CourseRepository extends BaseRepository {
  constructor(CourseDb) {
    super(CourseDb);
  }

  async getAllWithoutPagination() {
    return await this.model.find();
  }

  async findByIdProfessor(id) {
    return await this.model.findByIdProfessor(id);
  }
}

module.exports = CourseRepository
```


### 3 - Interface segregation principle(ISP)

#### Descripci贸n
- No se debe obligar a los clientes a depender de m茅todos que no utilizan. Cuando se requiere que una Clase realice acciones que no son 煤tiles, es un desperdicio y puede producir errores inesperados si la Clase no tiene la capacidad de realizar esas acciones.
- Una clase debe realizar solo las acciones necesarias para cumplir su funci贸n. Cualquier otra acci贸n debe eliminarse por completo o moverse a otro lugar si otra Clase podr铆a usarla en el futuro.

#### Fragmento de C贸digo
Los metodos principales usados para el CRUD estan definidos tanto en base.repository.js como en base.service.js respectivamente , aqui cumplimos con lo mecionado anteriormente , de que no se debe colocar funcionalidades que no usemos , es por ello que estas clases definen solo acciones que otra clases podr铆a cumplir en un futuro , y en general las que toda clase debe usar.  

Implementaci贸n de base repository , asi mismo esta clase funciona como interfaz entre los mmodels y los services

``` Javascript
class BaseRepository {
  constructor(model) {
    this.model = model;
  }
  async get(id) {
    return this.model.get(id);
  }
  async getAll() {
    return this.model.getAll();
  }
  async getByName(name) {
    return this.model.getByName(name);
  }
  async create(entity) {
    return this.model.create(entity);
  }
  async update(entity) {
    return this.model.update(entity);
  }
  async delete(id) {
    return this.model.delete(id);
  }
}
```

Implementaci贸n de Base Service , asi mismo esta clase funciona como interfaz entre los controllers y los repository

``` javascript
class BaseService {
  constructor(Repository) {
    this.repository = Repository;
  }
  async get(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro id debe ser enviado";
      throw error;
    }

    const entity = await this.repository.get(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getByName(name) {
    if (!name) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro name debe ser enviado";
      throw error;
    }

    const entity = await this.repository.getByName(name);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getAll() {
    const entity = await this.repository.getAll();
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async create(data) {
    const entity = await this.repository.create(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async update(data) {
    const entity = await this.repository.update(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async delete(id) {
    const entity = await this.repository.delete(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }
}
```

### 4 - Liskov Substitution Principle

#### Descripci贸n

Cuando una Clase hija no puede realizar las mismas acciones que su Clase padre, esto puede causar errores.

Si tienes una clase y creas otra clase a partir de ella, 茅sta se convierte en padre y la nueva clase en hijo. La clase hija debe ser capaz de hacer todo lo que la clase padre puede hacer. Este proceso se llama Herencia.

La clase hija debe ser capaz de procesar las mismas peticiones y entregar el mismo resultado que la clase padre o puede entregar un resultado que sea del mismo tipo.

La imagen muestra que la clase padre entrega caf茅 (puede ser cualquier tipo de caf茅). Es aceptable que la Clase hija entregue Cappucino porque es un tipo espec铆fico de Caf茅, pero NO es aceptable que entregue Agua.

Si la Clase hija no cumple con estos requisitos, significa que la Clase hija ha cambiado completamente y viola este principio.

#### Objetivo

Este principio tiene como objetivo reforzar la consistencia para que la Clase padre o su Clase hija puedan ser utilizadas de la misma manera sin ning煤n error.

#### Fragmento de c贸digo

```javascript
// PARENT

class BaseService {
  constructor(Repository) {
    this.repository = Repository;
  }
  async get(id) {
    if (!id) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro id debe ser enviado";
      throw error;
    }

    const entity = await this.repository.get(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getByName(name) {
    if (!name) {
      const error = new Error();
      error.status = 400;
      error.message = "Parametro name debe ser enviado";
      throw error;
    }

    const entity = await this.repository.getByName(name);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async getAll() {
    const entity = await this.repository.getAll();
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async create(data) {
    const entity = await this.repository.create(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async update(data) {
    const entity = await this.repository.update(data);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }

  async delete(id) {
    const entity = await this.repository.delete(id);
    if (!entity) {
      const error = new Error();
      error.status = 400;
      error.message = "Entidad no encontrada";
      throw error;
    }
    return entity;
  }
}

module.exports = BaseService;

// CHILD

const BaseService = require("./base.service");

class CityService extends BaseService {
  constructor(CityRepository) {
    super(CityRepository);
    this._cityRepository = CityRepository;
  }
}

module.exports = CityService;

 ```
 
 ## PRINCIPIOS DE DDD
 
 ### 1 - Ubiquitous Lenguage
 
 #### Descripci贸n 
- El lenguaje ubicuo debe expresarse en el modelo de dominio.
- Ubiquitous Language une a las personas del equipo del proyecto.
- Ubiquitous Language elimina imprecisiones y contradicciones de los expertos del dominio.
- El lenguaje ubicuo no es un lenguaje de negocios impuesto por expertos en dominios.
- El lenguaje ubicuo no es un lenguaje utilizado en las industrias.
- El lenguaje ubicuo evoluciona con el tiempo, no se define por completo en una sola reuni贸n.
- Los conceptos que no forman parte del Lenguaje Ubicuo deben ser rechazados.

 #### Fragmento de c贸digo
 
 ### 2 - Persistance Ignorance
 
 #### Descripci贸n 
 - Dentro de DDD no se graba se persiste
 - El almacenamiento de datos no condiciona el modelo
 - La utilizaci贸n de la informaci贸n que provee el modelo esta desligada de la forma de presentaci贸n.
 
 #### Fragmento de c贸digo
 
 ### 3 - Services
 #### Descripci贸n 
 - Los servicios de la aplicaci贸n son la interfaz utilizada por el mundo exterior, donde el mundo exterior no puede comunicarse a trav茅s de nuestros objetos Entidad.
 - La intefaz puede obtener representaciones no directas de ellos. 
 - Los Servicios de aplicaciones asignan mensajes externos a operaciones y procesos internos
 - Los servicios se encargan de la comunicaci贸n entre las capas de Dominio e Infraestructura para proporcionar operaciones cohesivas para clientes externos.
 #### Fragmento de c贸digo
 
